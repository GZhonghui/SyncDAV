// Generated by AI

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path"
	"strings"
)

type Config struct {
	WebDAVURL string `json:"webdav_url"`
	Username  string `json:"username"`
	Password  string `json:"password"`
	TargetDir string `json:"target_path"`
}

var client = &http.Client{}
var config Config

// LoadConfig loads WebDAV configuration from a JSON file
func LoadConfig(filename string) error {
	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	return json.NewDecoder(file).Decode(&config)
}

// DownloadFile downloads a single file from WebDAV to a local path
func DownloadFile(remotePath, localPath string) error {
	req, err := http.NewRequest("GET", remotePath, nil)
	if err != nil {
		return err
	}
	req.SetBasicAuth(config.Username, config.Password)

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	out, err := os.Create(localPath)
	if err != nil {
		return err
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)
	return err
}

func ListAndDownload(remoteBase, localBase string) error {
	propfindBody := `<?xml version="1.0"?>
	<d:propfind xmlns:d="DAV:">
		<d:allprop/>
	</d:propfind>`

	req, err := http.NewRequest("PROPFIND", remoteBase, strings.NewReader(propfindBody))
	if err != nil {
		return err
	}
	req.Header.Set("Depth", "1")
	req.Header.Set("Content-Type", "application/xml")
	req.SetBasicAuth(config.Username, config.Password)

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	buf := new(strings.Builder)
	_, err = io.Copy(buf, resp.Body)
	if err != nil {
		return err
	}

	body := buf.String()
	lines := strings.Split(body, "<d:response>")

	for _, line := range lines {
		if !strings.Contains(line, "<d:href>") {
			continue
		}
		start := strings.Index(line, "<d:href>") + len("<d:href>")
		end := strings.Index(line, "</d:href>")
		if start >= end {
			continue
		}
		href := line[start:end]

		// Normalize URL
		fullURL := ""
		if strings.HasPrefix(href, "http") {
			fullURL = href
		} else {
			fullURL = strings.TrimRight(config.WebDAVURL, "/") + href
		}
		// bugs to fix
		fmt.Println("log: fullURL =", fullURL)

		// Skip folders (end with /)
		if strings.HasSuffix(href, "/") {
			continue
		}

		// Get local file name from full href path
		segments := strings.Split(href, "/")
		filename := segments[len(segments)-1]
		localPath := path.Join(localBase, filename)

		fmt.Printf("Downloading %s -> %s\n", fullURL, localPath)
		err := DownloadFile(fullURL, localPath)
		if err != nil {
			fmt.Println("Download error:", err)
		}
	}

	return nil
}

func main() {
	// Load config from config.json
	err := LoadConfig("server.json")
	if err != nil {
		fmt.Println("Failed to load config:", err)
		return
	}

	// Ensure target directory exists
	err = os.MkdirAll(config.TargetDir, 0755)
	if err != nil {
		fmt.Println("Failed to create target directory:", err)
		return
	}

	// Start synchronization
	err = ListAndDownload(config.WebDAVURL, config.TargetDir)
	if err != nil {
		fmt.Println("Sync failed:", err)
	} else {
		fmt.Println("Sync completed successfully.")
	}
}
